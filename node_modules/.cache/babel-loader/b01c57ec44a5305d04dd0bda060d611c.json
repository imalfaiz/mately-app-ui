{"ast":null,"code":"// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// ┌────────────────────────────────────────────────────────────┐ \\\\\n// │ Eve 0.5.4 - JavaScript Events Library                      │ \\\\\n// ├────────────────────────────────────────────────────────────┤ \\\\\n// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\n// └────────────────────────────────────────────────────────────┘ \\\\\n(function (glob) {\n  var version = \"0.5.4\",\n      has = \"hasOwnProperty\",\n      separator = /[\\.\\/]/,\n      comaseparator = /\\s*,\\s*/,\n      wildcard = \"*\",\n      numsort = function (a, b) {\n    return a - b;\n  },\n      current_event,\n      stop,\n      events = {\n    n: {}\n  },\n      firstDefined = function () {\n    for (var i = 0, ii = this.length; i < ii; i++) {\n      if (typeof this[i] != \"undefined\") {\n        return this[i];\n      }\n    }\n  },\n      lastDefined = function () {\n    var i = this.length;\n\n    while (--i) {\n      if (typeof this[i] != \"undefined\") {\n        return this[i];\n      }\n    }\n  },\n      objtos = Object.prototype.toString,\n      Str = String,\n      isArray = Array.isArray || function (ar) {\n    return ar instanceof Array || objtos.call(ar) == \"[object Array]\";\n  },\n\n  /*\\\n   * eve\n   [ method ]\n    * Fires event with given `name`, given scope and other parameters.\n    - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n   - scope (object) context for the event handlers\n   - varargs (...) the rest of arguments will be sent to event handlers\n    = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n  \\*/\n  eve = function (name, scope) {\n    var oldstop = stop,\n        args = Array.prototype.slice.call(arguments, 2),\n        listeners = eve.listeners(name),\n        z = 0,\n        l,\n        indexed = [],\n        queue = {},\n        out = [],\n        ce = current_event;\n    out.firstDefined = firstDefined;\n    out.lastDefined = lastDefined;\n    current_event = name;\n    stop = 0;\n\n    for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n      indexed.push(listeners[i].zIndex);\n\n      if (listeners[i].zIndex < 0) {\n        queue[listeners[i].zIndex] = listeners[i];\n      }\n    }\n\n    indexed.sort(numsort);\n\n    while (indexed[z] < 0) {\n      l = queue[indexed[z++]];\n      out.push(l.apply(scope, args));\n\n      if (stop) {\n        stop = oldstop;\n        return out;\n      }\n    }\n\n    for (i = 0; i < ii; i++) {\n      l = listeners[i];\n\n      if (\"zIndex\" in l) {\n        if (l.zIndex == indexed[z]) {\n          out.push(l.apply(scope, args));\n\n          if (stop) {\n            break;\n          }\n\n          do {\n            z++;\n            l = queue[indexed[z]];\n            l && out.push(l.apply(scope, args));\n\n            if (stop) {\n              break;\n            }\n          } while (l);\n        } else {\n          queue[l.zIndex] = l;\n        }\n      } else {\n        out.push(l.apply(scope, args));\n\n        if (stop) {\n          break;\n        }\n      }\n    }\n\n    stop = oldstop;\n    current_event = ce;\n    return out;\n  }; // Undocumented. Debug only.\n\n\n  eve._events = events;\n  /*\\\n   * eve.listeners\n   [ method ]\n    * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n    - name (string) name of the event, dot (`.`) or slash (`/`) separated\n    = (array) array of event handlers\n  \\*/\n\n  eve.listeners = function (name) {\n    var names = isArray(name) ? name : name.split(separator),\n        e = events,\n        item,\n        items,\n        k,\n        i,\n        ii,\n        j,\n        jj,\n        nes,\n        es = [e],\n        out = [];\n\n    for (i = 0, ii = names.length; i < ii; i++) {\n      nes = [];\n\n      for (j = 0, jj = es.length; j < jj; j++) {\n        e = es[j].n;\n        items = [e[names[i]], e[wildcard]];\n        k = 2;\n\n        while (k--) {\n          item = items[k];\n\n          if (item) {\n            nes.push(item);\n            out = out.concat(item.f || []);\n          }\n        }\n      }\n\n      es = nes;\n    }\n\n    return out;\n  };\n  /*\\\n   * eve.separator\n   [ method ]\n    * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours\n   * here. Be aware that if you pass a string longer than one character it will be treated as\n   * a list of characters.\n    - separator (string) new separator. Empty string resets to default: `.` or `/`.\n  \\*/\n\n\n  eve.separator = function (sep) {\n    if (sep) {\n      sep = Str(sep).replace(/(?=[\\.\\^\\]\\[\\-])/g, \"\\\\\");\n      sep = \"[\" + sep + \"]\";\n      separator = new RegExp(sep);\n    } else {\n      separator = /[\\.\\/]/;\n    }\n  };\n  /*\\\n   * eve.on\n   [ method ]\n   **\n   * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\n   | eve.on(\"*.under.*\", f);\n   | eve(\"mouse.under.floor\"); // triggers f\n   * Use @eve to trigger the listener.\n   **\n   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n   - f (function) event handler function\n   **\n   - name (array) if you don’t want to use separators, you can use array of strings\n   - f (function) event handler function\n   **\n   = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.\n   > Example:\n   | eve.on(\"mouse\", eatIt)(2);\n   | eve.on(\"mouse\", scream);\n   | eve.on(\"mouse\", catchIt)(1);\n   * This will ensure that `catchIt` function will be called before `eatIt`.\n   *\n   * If you want to put your handler before non-indexed handlers, specify a negative value.\n   * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\n  \\*/\n\n\n  eve.on = function (name, f) {\n    if (typeof f != \"function\") {\n      return function () {};\n    }\n\n    var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n\n    for (var i = 0, ii = names.length; i < ii; i++) {\n      (function (name) {\n        var names = isArray(name) ? name : Str(name).split(separator),\n            e = events,\n            exist;\n\n        for (var i = 0, ii = names.length; i < ii; i++) {\n          e = e.n;\n          e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {\n            n: {}\n          });\n        }\n\n        e.f = e.f || [];\n\n        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n          exist = true;\n          break;\n        }\n\n        !exist && e.f.push(f);\n      })(names[i]);\n    }\n\n    return function (zIndex) {\n      if (+zIndex == +zIndex) {\n        f.zIndex = +zIndex;\n      }\n    };\n  };\n  /*\\\n   * eve.f\n   [ method ]\n   **\n   * Returns function that will fire given event with optional arguments.\n   * Arguments that will be passed to the result function will be also\n   * concated to the list of final arguments.\n   | el.onclick = eve.f(\"click\", 1, 2);\n   | eve.on(\"click\", function (a, b, c) {\n   |     console.log(a, b, c); // 1, 2, [event object]\n   | });\n   - event (string) event name\n   - varargs (…) and any other arguments\n   = (function) possible event handler function\n  \\*/\n\n\n  eve.f = function (event) {\n    var attrs = [].slice.call(arguments, 1);\n    return function () {\n      eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n    };\n  };\n  /*\\\n   * eve.stop\n   [ method ]\n   **\n   * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n  \\*/\n\n\n  eve.stop = function () {\n    stop = 1;\n  };\n  /*\\\n   * eve.nt\n   [ method ]\n   **\n   * Could be used inside event handler to figure out actual name of the event.\n   **\n   - subname (string) #optional subname of the event\n   **\n   = (string) name of the event, if `subname` is not specified\n   * or\n   = (boolean) `true`, if current event’s name contains `subname`\n  \\*/\n\n\n  eve.nt = function (subname) {\n    var cur = isArray(current_event) ? current_event.join(\".\") : current_event;\n\n    if (subname) {\n      return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(cur);\n    }\n\n    return cur;\n  };\n  /*\\\n   * eve.nts\n   [ method ]\n   **\n   * Could be used inside event handler to figure out actual name of the event.\n   **\n   **\n   = (array) names of the event\n  \\*/\n\n\n  eve.nts = function () {\n    return isArray(current_event) ? current_event : current_event.split(separator);\n  };\n  /*\\\n   * eve.off\n   [ method ]\n   **\n   * Removes given function from the list of event listeners assigned to given name.\n   * If no arguments specified all the events will be cleared.\n   **\n   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n   - f (function) event handler function\n  \\*/\n\n  /*\\\n   * eve.unbind\n   [ method ]\n   **\n   * See @eve.off\n  \\*/\n\n\n  eve.off = eve.unbind = function (name, f) {\n    if (!name) {\n      eve._events = events = {\n        n: {}\n      };\n      return;\n    }\n\n    var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n\n    if (names.length > 1) {\n      for (var i = 0, ii = names.length; i < ii; i++) {\n        eve.off(names[i], f);\n      }\n\n      return;\n    }\n\n    names = isArray(name) ? name : Str(name).split(separator);\n    var e,\n        key,\n        splice,\n        i,\n        ii,\n        j,\n        jj,\n        cur = [events],\n        inodes = [];\n\n    for (i = 0, ii = names.length; i < ii; i++) {\n      for (j = 0; j < cur.length; j += splice.length - 2) {\n        splice = [j, 1];\n        e = cur[j].n;\n\n        if (names[i] != wildcard) {\n          if (e[names[i]]) {\n            splice.push(e[names[i]]);\n            inodes.unshift({\n              n: e,\n              name: names[i]\n            });\n          }\n        } else {\n          for (key in e) if (e[has](key)) {\n            splice.push(e[key]);\n            inodes.unshift({\n              n: e,\n              name: key\n            });\n          }\n        }\n\n        cur.splice.apply(cur, splice);\n      }\n    }\n\n    for (i = 0, ii = cur.length; i < ii; i++) {\n      e = cur[i];\n\n      while (e.n) {\n        if (f) {\n          if (e.f) {\n            for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n              e.f.splice(j, 1);\n              break;\n            }\n\n            !e.f.length && delete e.f;\n          }\n\n          for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n            var funcs = e.n[key].f;\n\n            for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n              funcs.splice(j, 1);\n              break;\n            }\n\n            !funcs.length && delete e.n[key].f;\n          }\n        } else {\n          delete e.f;\n\n          for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n            delete e.n[key].f;\n          }\n        }\n\n        e = e.n;\n      }\n    } // prune inner nodes in path\n\n\n    prune: for (i = 0, ii = inodes.length; i < ii; i++) {\n      e = inodes[i];\n\n      for (key in e.n[e.name].f) {\n        // not empty (has listeners)\n        continue prune;\n      }\n\n      for (key in e.n[e.name].n) {\n        // not empty (has children)\n        continue prune;\n      } // is empty\n\n\n      delete e.n[e.name];\n    }\n  };\n  /*\\\n   * eve.once\n   [ method ]\n   **\n   * Binds given event handler with a given name to only run once then unbind itself.\n   | eve.once(\"login\", f);\n   | eve(\"login\"); // triggers f\n   | eve(\"login\"); // no listeners\n   * Use @eve to trigger the listener.\n   **\n   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n   - f (function) event handler function\n   **\n   = (function) same return function as @eve.on\n  \\*/\n\n\n  eve.once = function (name, f) {\n    var f2 = function () {\n      eve.off(name, f2);\n      return f.apply(this, arguments);\n    };\n\n    return eve.on(name, f2);\n  };\n  /*\\\n   * eve.version\n   [ property (string) ]\n   **\n   * Current version of the library.\n  \\*/\n\n\n  eve.version = version;\n\n  eve.toString = function () {\n    return \"You are running Eve \" + version;\n  };\n\n  glob.eve = eve;\n  typeof module != \"undefined\" && module.exports ? module.exports = eve : typeof define === \"function\" && define.amd ? define(\"eve\", [], function () {\n    return eve;\n  }) : glob.eve = eve;\n})(typeof window != \"undefined\" ? window : this);","map":{"version":3,"names":["glob","version","has","separator","comaseparator","wildcard","numsort","a","b","current_event","stop","events","n","firstDefined","i","ii","length","lastDefined","objtos","Object","prototype","toString","Str","String","isArray","Array","ar","call","eve","name","scope","oldstop","args","slice","arguments","listeners","z","l","indexed","queue","out","ce","push","zIndex","sort","apply","_events","names","split","e","item","items","k","j","jj","nes","es","concat","f","sep","replace","RegExp","on","exist","hasOwnProperty","event","attrs","nt","subname","cur","join","test","nts","off","unbind","key","splice","inodes","unshift","funcs","prune","once","f2","module","exports","define","amd","window"],"sources":["C:/Users/moham/OneDrive/Desktop/major-project/node_modules/eve/eve.js"],"sourcesContent":["// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// ┌────────────────────────────────────────────────────────────┐ \\\\\n// │ Eve 0.5.4 - JavaScript Events Library                      │ \\\\\n// ├────────────────────────────────────────────────────────────┤ \\\\\n// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\n// └────────────────────────────────────────────────────────────┘ \\\\\n\n(function (glob) {\n    var version = \"0.5.4\",\n        has = \"hasOwnProperty\",\n        separator = /[\\.\\/]/,\n        comaseparator = /\\s*,\\s*/,\n        wildcard = \"*\",\n        numsort = function (a, b) {\n            return a - b;\n        },\n        current_event,\n        stop,\n        events = {n: {}},\n        firstDefined = function () {\n            for (var i = 0, ii = this.length; i < ii; i++) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n        lastDefined = function () {\n            var i = this.length;\n            while (--i) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n        objtos = Object.prototype.toString,\n        Str = String,\n        isArray = Array.isArray || function (ar) {\n            return ar instanceof Array || objtos.call(ar) == \"[object Array]\";\n        },\n    /*\\\n     * eve\n     [ method ]\n\n     * Fires event with given `name`, given scope and other parameters.\n\n     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n     - scope (object) context for the event handlers\n     - varargs (...) the rest of arguments will be sent to event handlers\n\n     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n    \\*/\n        eve = function (name, scope) {\n            var oldstop = stop,\n                args = Array.prototype.slice.call(arguments, 2),\n                listeners = eve.listeners(name),\n                z = 0,\n                l,\n                indexed = [],\n                queue = {},\n                out = [],\n                ce = current_event;\n            out.firstDefined = firstDefined;\n            out.lastDefined = lastDefined;\n            current_event = name;\n            stop = 0;\n            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n                indexed.push(listeners[i].zIndex);\n                if (listeners[i].zIndex < 0) {\n                    queue[listeners[i].zIndex] = listeners[i];\n                }\n            }\n            indexed.sort(numsort);\n            while (indexed[z] < 0) {\n                l = queue[indexed[z++]];\n                out.push(l.apply(scope, args));\n                if (stop) {\n                    stop = oldstop;\n                    return out;\n                }\n            }\n            for (i = 0; i < ii; i++) {\n                l = listeners[i];\n                if (\"zIndex\" in l) {\n                    if (l.zIndex == indexed[z]) {\n                        out.push(l.apply(scope, args));\n                        if (stop) {\n                            break;\n                        }\n                        do {\n                            z++;\n                            l = queue[indexed[z]];\n                            l && out.push(l.apply(scope, args));\n                            if (stop) {\n                                break;\n                            }\n                        } while (l)\n                    } else {\n                        queue[l.zIndex] = l;\n                    }\n                } else {\n                    out.push(l.apply(scope, args));\n                    if (stop) {\n                        break;\n                    }\n                }\n            }\n            stop = oldstop;\n            current_event = ce;\n            return out;\n        };\n    // Undocumented. Debug only.\n    eve._events = events;\n    /*\\\n     * eve.listeners\n     [ method ]\n\n     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\n     = (array) array of event handlers\n    \\*/\n    eve.listeners = function (name) {\n        var names = isArray(name) ? name : name.split(separator),\n            e = events,\n            item,\n            items,\n            k,\n            i,\n            ii,\n            j,\n            jj,\n            nes,\n            es = [e],\n            out = [];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            nes = [];\n            for (j = 0, jj = es.length; j < jj; j++) {\n                e = es[j].n;\n                items = [e[names[i]], e[wildcard]];\n                k = 2;\n                while (k--) {\n                    item = items[k];\n                    if (item) {\n                        nes.push(item);\n                        out = out.concat(item.f || []);\n                    }\n                }\n            }\n            es = nes;\n        }\n        return out;\n    };\n    /*\\\n     * eve.separator\n     [ method ]\n\n     * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours\n     * here. Be aware that if you pass a string longer than one character it will be treated as\n     * a list of characters.\n\n     - separator (string) new separator. Empty string resets to default: `.` or `/`.\n    \\*/\n    eve.separator = function (sep) {\n        if (sep) {\n            sep = Str(sep).replace(/(?=[\\.\\^\\]\\[\\-])/g, \"\\\\\");\n            sep = \"[\" + sep + \"]\";\n            separator = new RegExp(sep);\n        } else {\n            separator = /[\\.\\/]/;\n        }\n    };\n    /*\\\n     * eve.on\n     [ method ]\n     **\n     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\n     | eve.on(\"*.under.*\", f);\n     | eve(\"mouse.under.floor\"); // triggers f\n     * Use @eve to trigger the listener.\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     - name (array) if you don’t want to use separators, you can use array of strings\n     - f (function) event handler function\n     **\n     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.\n     > Example:\n     | eve.on(\"mouse\", eatIt)(2);\n     | eve.on(\"mouse\", scream);\n     | eve.on(\"mouse\", catchIt)(1);\n     * This will ensure that `catchIt` function will be called before `eatIt`.\n     *\n     * If you want to put your handler before non-indexed handlers, specify a negative value.\n     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\n    \\*/\n    eve.on = function (name, f) {\n        if (typeof f != \"function\") {\n            return function () {};\n        }\n        var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n        for (var i = 0, ii = names.length; i < ii; i++) {\n            (function (name) {\n                var names = isArray(name) ? name : Str(name).split(separator),\n                    e = events,\n                    exist;\n                for (var i = 0, ii = names.length; i < ii; i++) {\n                    e = e.n;\n                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\n                }\n                e.f = e.f || [];\n                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n                    exist = true;\n                    break;\n                }\n                !exist && e.f.push(f);\n            }(names[i]));\n        }\n        return function (zIndex) {\n            if (+zIndex == +zIndex) {\n                f.zIndex = +zIndex;\n            }\n        };\n    };\n    /*\\\n     * eve.f\n     [ method ]\n     **\n     * Returns function that will fire given event with optional arguments.\n     * Arguments that will be passed to the result function will be also\n     * concated to the list of final arguments.\n     | el.onclick = eve.f(\"click\", 1, 2);\n     | eve.on(\"click\", function (a, b, c) {\n     |     console.log(a, b, c); // 1, 2, [event object]\n     | });\n     - event (string) event name\n     - varargs (…) and any other arguments\n     = (function) possible event handler function\n    \\*/\n    eve.f = function (event) {\n        var attrs = [].slice.call(arguments, 1);\n        return function () {\n            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n        };\n    };\n    /*\\\n     * eve.stop\n     [ method ]\n     **\n     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n    \\*/\n    eve.stop = function () {\n        stop = 1;\n    };\n    /*\\\n     * eve.nt\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     - subname (string) #optional subname of the event\n     **\n     = (string) name of the event, if `subname` is not specified\n     * or\n     = (boolean) `true`, if current event’s name contains `subname`\n    \\*/\n    eve.nt = function (subname) {\n        var cur = isArray(current_event) ? current_event.join(\".\") : current_event;\n        if (subname) {\n            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(cur);\n        }\n        return cur;\n    };\n    /*\\\n     * eve.nts\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     **\n     = (array) names of the event\n    \\*/\n    eve.nts = function () {\n        return isArray(current_event) ? current_event : current_event.split(separator);\n    };\n    /*\\\n     * eve.off\n     [ method ]\n     **\n     * Removes given function from the list of event listeners assigned to given name.\n     * If no arguments specified all the events will be cleared.\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n    \\*/\n    /*\\\n     * eve.unbind\n     [ method ]\n     **\n     * See @eve.off\n    \\*/\n    eve.off = eve.unbind = function (name, f) {\n        if (!name) {\n            eve._events = events = {n: {}};\n            return;\n        }\n        var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n        if (names.length > 1) {\n            for (var i = 0, ii = names.length; i < ii; i++) {\n                eve.off(names[i], f);\n            }\n            return;\n        }\n        names = isArray(name) ? name : Str(name).split(separator);\n        var e,\n            key,\n            splice,\n            i, ii, j, jj,\n            cur = [events],\n            inodes = [];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            for (j = 0; j < cur.length; j += splice.length - 2) {\n                splice = [j, 1];\n                e = cur[j].n;\n                if (names[i] != wildcard) {\n                    if (e[names[i]]) {\n                        splice.push(e[names[i]]);\n                        inodes.unshift({\n                            n: e,\n                            name: names[i]\n                        });\n                    }\n                } else {\n                    for (key in e) if (e[has](key)) {\n                        splice.push(e[key]);\n                        inodes.unshift({\n                            n: e,\n                            name: key\n                        });\n                    }\n                }\n                cur.splice.apply(cur, splice);\n            }\n        }\n        for (i = 0, ii = cur.length; i < ii; i++) {\n            e = cur[i];\n            while (e.n) {\n                if (f) {\n                    if (e.f) {\n                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n                            e.f.splice(j, 1);\n                            break;\n                        }\n                        !e.f.length && delete e.f;\n                    }\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        var funcs = e.n[key].f;\n                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n                            funcs.splice(j, 1);\n                            break;\n                        }\n                        !funcs.length && delete e.n[key].f;\n                    }\n                } else {\n                    delete e.f;\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        delete e.n[key].f;\n                    }\n                }\n                e = e.n;\n            }\n        }\n        // prune inner nodes in path\n        prune: for (i = 0, ii = inodes.length; i < ii; i++) {\n            e = inodes[i];\n            for (key in e.n[e.name].f) {\n                // not empty (has listeners)\n                continue prune;\n            }\n            for (key in e.n[e.name].n) {\n                // not empty (has children)\n                continue prune;\n            }\n            // is empty\n            delete e.n[e.name];\n        }\n    };\n    /*\\\n     * eve.once\n     [ method ]\n     **\n     * Binds given event handler with a given name to only run once then unbind itself.\n     | eve.once(\"login\", f);\n     | eve(\"login\"); // triggers f\n     | eve(\"login\"); // no listeners\n     * Use @eve to trigger the listener.\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) same return function as @eve.on\n    \\*/\n    eve.once = function (name, f) {\n        var f2 = function () {\n            eve.off(name, f2);\n            return f.apply(this, arguments);\n        };\n        return eve.on(name, f2);\n    };\n    /*\\\n     * eve.version\n     [ property (string) ]\n     **\n     * Current version of the library.\n    \\*/\n    eve.version = version;\n    eve.toString = function () {\n        return \"You are running Eve \" + version;\n    };\n    glob.eve = eve;\n    typeof module != \"undefined\" && module.exports ? module.exports = eve : typeof define === \"function\" && define.amd ? define(\"eve\", [], function () { return eve; }) : glob.eve = eve;\n})(typeof window != \"undefined\" ? window : this);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}